/*
 * generated by Xtext 2.12.0
 */
package uk.ac.kcl.inf.gts_morpher.tests.syntax

import com.google.common.collect.Iterables
import com.google.inject.Inject
import org.eclipse.xtext.diagnostics.Diagnostic
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.AttributeMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ClassMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSFamilyChoice
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSSpecificationModule
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSWeave
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GtsMorpherPackage
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.LinkMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ObjectMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ReferenceMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.SlotMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.WeaveOption
import uk.ac.kcl.inf.gts_morpher.tests.AbstractTest
import uk.ac.kcl.inf.gts_morpher.tests.GTSMorpherInjectorProvider
import uk.ac.kcl.inf.gts_morpher.validation.GTSMorpherValidator

import static org.junit.Assert.*

import static extension uk.ac.kcl.inf.gts_morpher.util.GTSSpecificationHelper.*
import static extension org.eclipse.emf.henshin.adapters.xtext.NamingHelper.*

@RunWith(XtextRunner)
@InjectWith(GTSMorpherInjectorProvider)
class ParsingAndValidationTests extends AbstractTest {
	@Inject
	ParseHelper<GTSSpecificationModule> parseHelper

	@Inject
	extension ValidationTestHelper

	protected override createResourceSet(String[] files) {
		super.createResourceSet(Iterables.concat(files, #["transformers.henshin"]))
	}

	private def createNormalResourceSet() {
		#[
			"server.ecore",
			"DEVSMM.ecore",
			"server.henshin",
			"devsmm.henshin",
			"A.ecore",
			"B.ecore",
			"A4.ecore",
			"A5.ecore",
			"B4.ecore",
			"C.ecore",
			"D.ecore",
			"A.henshin",
			"B.henshin",
			"B2.henshin",
			"A3.henshin",
			"B3.henshin",
			"A4.henshin",
			"B4.henshin",
			"A5.henshin",
			"B5.henshin",
			"C.henshin",
			"D.henshin"
		].createResourceSet
	}

	private def createInterfaceResourceSet() {
		#["storing_server.ecore", "DEVSMM.ecore", "storing_server.henshin", "devsmm.henshin"].createResourceSet
	}

	/**
	 * Tests basic parsing and linking for a sunshine case
	 */
	@Test
	def void parsingBasic() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from gts ServerSystem {
					metamodel: "server"
				}
				to gts DEVsMMSystem {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)
	}

	/**
	 * Tests basic parsing and linking for a sunshine case
	 */
	@Test
	def void parsingBasicXDsml() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from xdsml ServerSystem {
					metamodel: "server"
				}
				to xdsml DEVsMMSystem {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)
	}

	/**
	 * Tests basic parsing and linking for a sunshine case with only a GTS Specification
	 */
	@Test
	def void parsingBasicJustGTS() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not load metamodel", result.gtss.head.metamodel.name)
		assertFalse("Export flag set", result.gtss.head.export)
	}

	/**
	 * Tests basic parsing and linking for a sunshine case with only a GTS Specification
	 */
	@Test
	def void parsingBasicJustGTSWithExport() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			export gts ServerSystem {
				metamodel: "server"
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not load metamodel", result.gtss.head.metamodel.name)
		assertTrue("Export flag not set", result.gtss.head.export)
	}

	/**
	 * Tests basic parsing and linking for a sunshine case
	 */
	@Test
	def void parsingBasicWithGTSReference() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
			}

			gts DEVsMMSystem {
				metamodel: "devsmm"
			}
			
			map {
				from ServerSystem
				
				to DEVsMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not load metamodel", result.gtss.head.metamodel.name)
		assertNotNull("Did not load metamodel", result.gtss.get(1).metamodel.name)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)
	}

	/**
	 * Test basic parsing with auto-complete annotation.
	 */
	@Test
	def void parsingAutoComplete() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertFalse("Set to unique auto-completion", result.mappings.head.uniqueCompletion)
	}

	/**
	 * Test basic parsing with auto-complete annotation claiming that can auto-complete without creating to-virtual rule mappings.
	 */
	@Test
	def void parsingAutoCompleteNoToVirtual() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete without-to-virtual map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertFalse("Set to unique auto-completion", result.mappings.head.uniqueCompletion)
		
		assertTrue("Not set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)
	}

	/**
	 * Test basic parsing with auto-complete annotation claiming that can auto-complete without creating to-virtual rule mappings.
	 */
	@Test
	def void parsingAutoCompleteAllowFromEmpty() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete allow-from-empty map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertFalse("Set to unique auto-completion", result.mappings.head.uniqueCompletion)
		
//		assertTrue("Not set to allow-from-empty", result.allowFromEmtpy)
		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)
	}

	/**
	 * Test basic parsing with auto-complete annotation claiming that can auto-complete without creating to-virtual rule mappings.
	 */
	@Test
	def void parsingAutoCompleteOnlyToIdentity() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete to-identity-only map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertFalse("Set to unique auto-completion", result.mappings.head.uniqueCompletion)
		
		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertTrue("Not set to toIdentityOnly", result.mappings.head.toIdentityOnly)
	}

	/**
	 * Tests basic parsing and linking for unique inclusion completion
	 */
	@Test
	def void parsingAutoCompleteUniqueInclusion() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique inclusion map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping { }
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)
		result.assertNoIssues

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique", result.mappings.head.uniqueCompletion)
		assertTrue("Not set to inclusion", result.mappings.head.inclusion)

		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)
	}

	/**
	 * Tests validation for unique inclusion completion against to-identity-only hint
	 */
	@Test
	def void validatingAutoCompleteUniqueInclusionHintConflict1() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique inclusion to-identity-only map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping { }
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique", result.mappings.head.uniqueCompletion)
		assertTrue("Not set to inclusion", result.mappings.head.inclusion)

		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertTrue("Not set to toIdentityOnly", result.mappings.head.toIdentityOnly)
		assertFalse("Set to allow-from-empty", result.mappings.head.allowFromEmtpy)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.INCLUSION_CANNOT_BE_TO_IDENTITY_ONLY)
	}

	/**
	 * Tests validation for unique inclusion completion against without-to-virtual hint
	 */
	@Test
	def void validatingAutoCompleteUniqueInclusionHintConflict2() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique inclusion without-to-virtual map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping { }
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique", result.mappings.head.uniqueCompletion)
		assertTrue("Not set to inclusion", result.mappings.head.inclusion)

		assertTrue("Not set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)
		assertFalse("Set to allow-from-empty", result.mappings.head.allowFromEmtpy)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.INCLUSION_CANNOT_BE_WITHOUT_TO_VIRTUAL)
	}

	/**
	 * Tests validation for unique inclusion completion against allow-from-empty hint
	 */
	@Test
	def void validatingAutoCompleteUniqueInclusionHintConflict3() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique inclusion allow-from-empty map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping { }
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique", result.mappings.head.uniqueCompletion)
		assertTrue("Not set to inclusion", result.mappings.head.inclusion)

		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)
		assertTrue("Not set to allow-from-empty", result.mappings.head.allowFromEmtpy)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.INCLUSION_CANNOT_BE_ALLOW_FROM_EMPTY)
	}

	/**
	 * Tests validation for unique inclusion completion checking consistency of source and target
	 */
	@Test
	def void validatingAutoCompleteUniqueInclusionMismatchingFromAndTo() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique inclusion map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping { }
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique", result.mappings.head.uniqueCompletion)
		assertTrue("Not set to inclusion", result.mappings.head.inclusion)

		assertFalse("Set to without-to-virtual", result.mappings.head.withoutToVirtual)
		assertFalse("Set to toIdentityOnly", result.mappings.head.toIdentityOnly)
		assertFalse("Set to allow-from-empty", result.mappings.head.allowFromEmtpy)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.INCLUSION_MUST_HAVE_SAME_SOURCE_AND_TARGET)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping
	 */
	@Test
	def void parsingBasicWithBehaviour() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
					
					rule process to process {
						// Test that empty rule maps are allowed
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find source rule", result.mappings.head.behaviourMapping.mappings.get(0).source.name)
		assertNotNull("Did not find target rule", result.mappings.head.behaviourMapping.mappings.get(0).target.name)

		val ruleMap = result.mappings.head.behaviourMapping.mappings.get(0)
		assertNotNull("Did not find source object", (ruleMap.element_mappings.get(0) as ObjectMapping).source.name)
		assertNotNull("Did not find target object", (ruleMap.element_mappings.get(0) as ObjectMapping).target.name)

		assertNotNull("Did not find source link", (ruleMap.element_mappings.get(1) as LinkMapping).source.name)
		assertNotNull("Did not find target link", (ruleMap.element_mappings.get(1) as LinkMapping).target.name)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping
	 */
	@Test
	def void parsingBasicWithBehaviourWithGTSReference() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
			
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map {
				from ServerSystem
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
					
					rule process to process {
						// Test that empty rule maps are allowed
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not load source package", result.gtss.head.metamodel.name)
		assertNotNull("Did not load target package", result.gtss.get(1).metamodel.name)
		assertNotNull("Did not load source behaviour", result.gtss.head.behaviour.name)
		assertNotNull("Did not load target behaviour", result.gtss.get(1).behaviour.name)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find source rule", result.mappings.head.behaviourMapping.mappings.get(0).source.name)
		assertNotNull("Did not find target rule", result.mappings.head.behaviourMapping.mappings.get(0).target.name)

		val ruleMap = result.mappings.head.behaviourMapping.mappings.get(0)
		assertNotNull("Did not find source object", (ruleMap.element_mappings.get(0) as ObjectMapping).source.name)
		assertNotNull("Did not find target object", (ruleMap.element_mappings.get(0) as ObjectMapping).target.name)

		assertNotNull("Did not find source link", (ruleMap.element_mappings.get(1) as LinkMapping).source.name)
		assertNotNull("Did not find target link", (ruleMap.element_mappings.get(1) as LinkMapping).target.name)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping
	 */
	@Test
	def void parsingBasicWithBehaviourWithRuleMapToIdentity() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to virtual identity
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find source rule", result.mappings.head.behaviourMapping.mappings.get(0).source.name)
		assertTrue("Expected rule to be marked as identity target", result.mappings.head.behaviourMapping.mappings.get(0).target_identity)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping
	 */
	@Test
	def void parsingBasicWithBehaviourWithRuleMapFromEmpty() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule empty to process
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find target rule", result.mappings.head.behaviourMapping.mappings.get(0).target.name)
		assertTrue("Expected rule to be marked as empty source", result.mappings.head.behaviourMapping.mappings.get(0).source_empty)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping for an interface-mapping
	 */
	@Test
	def void parsingBasicWithBehaviourAndInterface() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find source rule", result.mappings.head.behaviourMapping.mappings.get(0).source.name)
		assertNotNull("Did not find target rule", result.mappings.head.behaviourMapping.mappings.get(0).target.name)

		val ruleMap = result.mappings.head.behaviourMapping.mappings.get(0)
		assertNotNull("Did not find source object", (ruleMap.element_mappings.get(0) as ObjectMapping).source.name)
		assertNotNull("Did not find target object", (ruleMap.element_mappings.get(0) as ObjectMapping).target.name)

		assertNotNull("Did not find source link", (ruleMap.element_mappings.get(1) as LinkMapping).source.name)
		assertNotNull("Did not find target link", (ruleMap.element_mappings.get(1) as LinkMapping).target.name)
	}

	/**
	 * Tests basic parsing and linking with behaviour mapping for an interface-mapping
	 */
	@Test
	def void parsingBasicWithBehaviourAndInterfaceAndGTSReferences() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem interface_of {
				metamodel: "server"
				behaviour: "serverRules"
			}
			
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map {
				from ServerSystem
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Set to auto-complete", !result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNotNull("Did not load source class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).source.name)
		assertNotNull("Did not load target class", (result.mappings.head.typeMapping.mappings.head as ClassMapping).target.name)

		assertNotNull("Did not load source reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)
		assertNotNull("Did not load target reference",
			(result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		assertNotNull("Did not find source rule", result.mappings.head.behaviourMapping.mappings.get(0).source.name)
		assertNotNull("Did not find target rule", result.mappings.head.behaviourMapping.mappings.get(0).target.name)

		val ruleMap = result.mappings.head.behaviourMapping.mappings.get(0)
		assertNotNull("Did not find source object", (ruleMap.element_mappings.get(0) as ObjectMapping).source.name)
		assertNotNull("Did not find target object", (ruleMap.element_mappings.get(0) as ObjectMapping).target.name)

		assertNotNull("Did not find source link", (ruleMap.element_mappings.get(1) as LinkMapping).source.name)
		assertNotNull("Did not find target link", (ruleMap.element_mappings.get(1) as LinkMapping).target.name)
	}

	/**
	 * Tests interface_of scoping rules
	 */
	@Test
	def void parsingInterfaceOfScopingRules() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					class server.ServerObserver => server.Server
					reference server.ServerObserver.server => server.Server.Out
					class server.Server => server.ServerObserver
					reference server.Server.Out => server.ServerObserver.server
					attribute server.Queue.count2 => server.Queue.count1 
					attribute server.Queue.count1 => server.Queue.count2 
				}
				
				behaviour_mapping {
					rule process2 to process2 {
						object so => so
						link [so->server:server] => [so->server:server]
						slot in_queue.count2 => in_queue.count2
						slot in_queue.count1 => in_queue.count1
					}
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertFalse("Set to auto-complete", result.mappings.head.autoComplete)

		assertNotNull("No type mapping", result.mappings.head.typeMapping)

		assertNotNull("Did not load source package", result.mappings.head.source.metamodel.name)
		assertNotNull("Did not load target package", result.mappings.head.target.metamodel.name)

		assertNull("Wrongly loaded source class", (result.mappings.head.typeMapping.mappings.get(0) as ClassMapping).source.name)
		assertNull("Wrongly loaded source reference", (result.mappings.head.typeMapping.mappings.get(1) as ReferenceMapping).source.name)

		assertNull("Wrongly loaded target class", (result.mappings.head.typeMapping.mappings.get(2) as ClassMapping).target.name)
		assertNull("Wrongly loaded target reference", (result.mappings.head.typeMapping.mappings.get(3) as ReferenceMapping).target.name)

		assertNull("Wrongly loaded source attribute", (result.mappings.head.typeMapping.mappings.get(4) as AttributeMapping).source.name)
		assertNull("Wrongly loaded target attribute", (result.mappings.head.typeMapping.mappings.get(5) as AttributeMapping).target.name)

		assertNotNull("Did not load source behaviour", result.mappings.head.source.behaviour.name)
		assertNotNull("Did not load target behaviour", result.mappings.head.target.behaviour.name)

		val ruleMap = result.mappings.head.behaviourMapping.mappings.head
		assertNotNull("Did not find source rule", ruleMap.source.name)
		assertNotNull("Did not find target rule", ruleMap.target.name)

		assertNull("Wrongly found source object", (ruleMap.element_mappings.get(0) as ObjectMapping).source.name)
		assertNull("Wrongly found target object", (ruleMap.element_mappings.get(0) as ObjectMapping).target.name)

		assertNull("Wrongly found source link", (ruleMap.element_mappings.get(1) as LinkMapping).source.type)
		assertNull("wrongly found target link", (ruleMap.element_mappings.get(1) as LinkMapping).target.type)

		assertNull("Wrongly found source slot", (ruleMap.element_mappings.get(2) as SlotMapping).source.type)
		assertNull("wrongly found target slot", (ruleMap.element_mappings.get(2) as SlotMapping).target.type)

		assertNotNull("Wrongly didn't find source slot", (ruleMap.element_mappings.get(3) as SlotMapping).source.type)
		assertNotNull("wrongly didn't find target slot", (ruleMap.element_mappings.get(3) as SlotMapping).target.type)
	}

	/**
	 * Test basic parsing with unique auto-complete annotation.
	 */
	@Test
	def void parsingUniqueAutoComplete() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertTrue("Not set to auto-complete", result.mappings.head.autoComplete)
		assertTrue("Not set to unique auto-complete", result.mappings.head.uniqueCompletion)
	}

	/**
	 * Test basic parsing with attribute mapping.
	 */
	@Test
	def void parsingBasicAttributeMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "C"
				}
				to {
					metamodel: "D"
				}
				
				type_mapping {
					class C.C1 => D.D1
					attribute C.C1.a1 => D.D1.a1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not resolve source attribute",
			(result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).source.name)
		assertNotNull("Did not resolve target attribute",
			(result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).target.name)
	}

	/**
	 * Test basic parsing with attribute mapping. We need to check this case to properly check the scoping rules as the attribute name 
	 * would be resolved even without the scoping rule (it is in the classpath). Here we check that we only allow attributes from the TGs 
	 * that are referenced.
	 */
	@Test
	def void parsingBasicAttributeMappingLinkError() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
				}
				to {
					metamodel: "B"
				}
				
				type_mapping {
					class A.A1 => B.B1
					attribute C.C1.a1 => D.D1.a1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNull("Did resolve source attribute", (result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).source.name)
		assertNull("Did resolve target attribute", (result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).target.name)
	}

	/**
	 * Test basic parsing with attribute mapping.
	 */
	@Test
	def void parsingBasicAttributeMappingWithBehaviour() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "C"
					behaviour: "CRules"
				}
				to {
					metamodel: "D"
					behaviour: "DRules"
				}
				
				type_mapping {
					class C.C1 => D.D1
					attribute C.C1.a1 => D.D1.a1
				}
				
				behaviour_mapping {
					rule do to do {
						object c1 => d1
						slot c1.a1 => d1.a1
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not resolve source attribute",
			(result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).source.name)
		assertNotNull("Did not resolve target attribute",
			(result.mappings.head.typeMapping.mappings.get(1) as AttributeMapping).target.name)

		assertNotNull("Did not resolve source slot",
			(result.mappings.head.behaviourMapping.mappings.head.element_mappings.get(1) as SlotMapping).source.name)
		assertNotNull("Did not resolve target slot",
			(result.mappings.head.behaviourMapping.mappings.head.element_mappings.get(1) as SlotMapping).target.name)
	}

	/**
	 * Test basic parsing with a GTS family specification
	 */
	@Test
	def void parsingBasicGTSFamily() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					family: {
						{
							metamodel: "server"
						}
						
						transformers: "transformerRules"
					}
					
					using [
						addSubClass(server.Server, "Server1"),
						addSubClass(server.Server, "Server2")
					]
				}
				
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server1 => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Didn't manage to load transformers.", (result.mappings.head.source.gts as GTSFamilyChoice).transformers.name)

		assertNotNull("Didn't find transformer being invoked",
			(result.mappings.head.source.gts as GTSFamilyChoice).transformationSteps.steps.head.unit.name)
	}

	/**
	 * Test basic parsing with a GTS family specification
	 */
	@Test
	def void parsingBasicGTSFamilyWithReference() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts_family ServerFamily {
				gts {
					metamodel: "server"
				}
				
				transformers: "transformerRules"
			}
			
			map {
				from {
					family: ServerFamily
					
					using [
						addSubClass(server.Server, "Server1"),
						addSubClass(server.Server, "Server2")
					]
				}
				
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server1 => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Didn't manage to load transformers.", (result.mappings.head.source.gts as GTSFamilyChoice).transformers.name)

		assertNotNull("Didn't find transformer being invoked",
			(result.mappings.head.source.gts as GTSFamilyChoice).transformationSteps.steps.head.unit.name)
	}

	/**
	 * Tests basic parsing of algebraic weave descriptions
	 */
	@Test
	def void parsingBasicAlgebraicWeave() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
			
			gts ServerInterface interface_of { ServerSystem }
			
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map ServerToDEVSMM {
				from ServerInterface
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
			
			gts DEVSMMWithServer {
				weave: {
					map1: interface_of (ServerSystem)
					map2: ServerToDEVSMM
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not resolve GTS metamodel reference", result.gtss.get(1).metamodel.name)
		assertNotNull("Did not resolve GTS behaviour reference", result.gtss.get(1).behaviour.name)
		assertTrue("Not set to interface_of", result.gtss.get(1).interface_mapping)

		result.assertNoError(GTSMorpherValidator.WEAVE_WITH_DIFFERENT_SOURCES)
	}

	/**
	 * Tests basic parsing of algebraic weave descriptions with naming conventions
	 */
	@Test
	def void parsingWeaveWithNameOptions() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
			
			gts ServerInterface interface_of { ServerSystem }
			
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map ServerToDEVSMM {
				from ServerInterface
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
			
			gts DEVSMMWithServer {
				weave (preferMap2TargetNames, dontLabelNonKernelElements): {
					map1: interface_of (ServerSystem)
					map2: ServerToDEVSMM
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		assertNotNull("Did not resolve GTS metamodel reference", result.gtss.get(1).metamodel.name)
		assertNotNull("Did not resolve GTS behaviour reference", result.gtss.get(1).behaviour.name)
		assertTrue("Not set to interface_of", result.gtss.get(1).interface_mapping)

		result.assertNoError(GTSMorpherValidator.WEAVE_WITH_DIFFERENT_SOURCES)
		
		assertTrue("Didn't record preferMap2TargetNames flag", (result.gtss.last.gts as GTSWeave).options.contains(WeaveOption.PREFER_MAP2_TARGET_NAMES))
		assertTrue("Didn't record dontLabelNonKernelElements flag", (result.gtss.last.gts as GTSWeave).options.contains(WeaveOption.DONT_LABEL_NON_KERNEL_ELEMENTS))
	}
	
	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void parsingBasicParameterMorphism() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertNoErrors
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
						param m => s
						param n => n
						param a2 => b2
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertNoIssues
	}

	/**
	 * Ensure parameter mappings are consistent with attribute mappings
	 */
	@Test
	def void validateParameterMorphismAgainstAttributeMappingsPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A4"
					behaviour: "A4Rules"
				}
				
				to {
					metamodel: "B4"
					behaviour: "B4Rules"
				}
				
				type_mapping {
					class A4.A1 => B4.B1
					attribute A4.A1.numA => B4.B1.numB
				}
				
				behaviour_mapping {
					rule test to test {
						param numberA => numberB
						object a1 => b1
						slot a1.numA => b1.numB
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertNoIssues
	}

	/**
	 * Ensure parameter mappings are consistent with attribute mappings
	 */
	@Test
	def void validateParameterMorphismAgainstAttributeMappingsWithInterfaceOfPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "A5"
					behaviour: "A5Rules"
				}
				
				to {
					metamodel: "B4"
					behaviour: "B5Rules"
				}
				
				type_mapping {
					class A5.A1 => B4.B1
					attribute A5.A1.numA => B4.B1.numB
				}
				
				behaviour_mapping {
					rule test to test {
						param a1 => b1
						param numberA => numberB
						object a1 => b1
						slot a1.numA => b1.numB
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertNoIssues
	}

	/**
	 * Ensure parameter mappings are consistent with attribute mappings
	 */
	@Test
	def void validateParameterMorphismAgainstAttributeMappingsWithInterfaceOfNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "A5"
					behaviour: "A5Rules"
				}
				
				to {
					metamodel: "B4"
					behaviour: "B5Rules"
				}
				
				type_mapping {
					class A5.A1 => B4.B1
					attribute A5.A1.numA => B4.B1.numB
				}
				
				behaviour_mapping {
					rule test to test {
						param a2 => b1
						param numberA2 => numberB
						object a1 => b1
						slot a1.numA => b1.numB
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertWarning(GtsMorpherPackage.Literals.RULE_MAPPING, GTSMorpherValidator.INCOMPLETE_RULE_MAPPING)
	}

	/**
	 * Ensure parameter mappings are consistent with attribute mappings
	 */
	@Test
	def void validateParameterMorphismAgainstAttributeMappingsNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A4"
					behaviour: "A4Rules"
				}
				
				to {
					metamodel: "B4"
					behaviour: "B4Rules"
				}
				
				type_mapping {
					class A4.A1 => B4.B1
					attribute A4.A1.numA => B4.B1.numB
				}
				
				behaviour_mapping {
					rule test to test {
						param numberA => numberB
						object a1 => b2
						slot a1.numA => b2.numB
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertError(GtsMorpherPackage.Literals.SLOT_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismNegative_NodeParameterMismatch() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
						param m => s
						param n => n
						param a2 => b2b
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertError(GtsMorpherPackage.Literals.RULE_PARAMETER_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismNegative_IncompleteParameterMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
						param m => s
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertWarning(GtsMorpherPackage.Literals.RULE_MAPPING, GTSMorpherValidator.INCOMPLETE_RULE_MAPPING)
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismNegative_TypeMismatch1() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b3
						param m => s
						param n => n
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertError(GtsMorpherPackage.Literals.RULE_PARAMETER_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismNegative_TypeMismatch2() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
						param m => n2
						param n => n
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertError(GtsMorpherPackage.Literals.RULE_PARAMETER_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)
	}

	/**
	 * Tests parsing of basic parameter morphism
	 */
	@Test
	def void validateBasicParameterMorphismNegative_KindMismatch() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "A"
					behaviour: "A3Rules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B3Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
					class A.A2 => B.B2
					reference A.A1.bs => B.B1._2s
					reference A.A2.a => B.B2.a
				}
				
				behaviour_mapping {
					rule do to do {
						param a1 => b1
						param m => s2
						param n => n
						object a1 => b1
						object a2 => b2
						link [a1->a2:bs] => [b1->b2:_2s]
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		
		result.assertError(GtsMorpherPackage.Literals.RULE_PARAMETER_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)
	}

	/**
	 * Tests basic validation of algebraic weave descriptions: checking that both mappings come from a common source
	 */
	@Test
	def void validateAlgebraicWeaveCommonSource() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
						
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map ServerToDEVSMM {
				from ServerSystem
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
			
			gts DEVSMMWithServer {
				weave: {
					map1: interface_of (ServerSystem)
					map2: ServerToDEVSMM
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_SPECIFICATION, GTSMorpherValidator.WEAVE_WITH_DIFFERENT_SOURCES)
	}

	/**
	 * Tests basic validation of algebraic weave descriptions: checking that both mappings come from a common source
	 */
	@Test
	def void validateAlgebraicWeaveNoInterfaceOf() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
						
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map ServerToDEVSMM {
				from ServerSystem
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
			
			gts DEVSMMWithServer {
				weave: {
					map1: ServerToDEVSMM
					map2: ServerToDEVSMM
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		result.assertNoError(GTSMorpherValidator.WEAVE_WITH_DIFFERENT_SOURCES)
	}

	/**
	 * Tests basic validation of algebraic weave descriptions: checking that both mappings are valid, complete morphisms
	 */
	@Test
	def void validateAlgebraicWeaveValidMorphisms() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			gts ServerSystem {
				metamodel: "server"
				behaviour: "serverRules"
			}
			
			gts ServerInterface interface_of { ServerSystem }
			
			gts DEVSMMSystem {
				metamodel: "devsmm"
				behaviour: "devsmmRules"
			}

			map ServerToDEVSMM {
				from ServerInterface
				to DEVSMMSystem
				
				type_mapping {
					class server.Server => devsmm.Machine
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object input => in_part
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
				}
			}
			
			gts DEVSMMWithServer {
				weave: {
					map1: interface_of (ServerSystem)
					map2: ServerToDEVSMM
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		result.assertNoError(GTSMorpherValidator.WEAVE_WITH_DIFFERENT_SOURCES)
		
		result.assertError(GtsMorpherPackage.Literals.GTS_WEAVE, GTSMorpherValidator.WEAVE_WITH_INVALID_MORPHISM)
	}

	/**
	 * Tests that we get the correct error messages when a type mapping is the wrong way around
	 */
	@Test
	def void crossedMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class devsmm.Machine => server.Server 
					reference devsmm.Machine.out => server.Server.Out
				}
				
				behaviour_mapping {
					rule process to process {
						object in_part => input
						link [tray->in_part:parts] => [in_queue->input:elts]
					}
					rule process to process {
						object in_part => input
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		// Expecting validation errors as source and target are switched in the class mapping
		val issues = result.validate()

		result.assertError(GtsMorpherPackage.Literals.CLASS_MAPPING, Diagnostic.LINKING_DIAGNOSTIC)
		result.assertError(GtsMorpherPackage.Literals.REFERENCE_MAPPING, Diagnostic.LINKING_DIAGNOSTIC)

//		(result.typeMapping.mappings.get(0) as ClassMapping).assertError(GtsMorpherPackage.Literals.CLASS_MAPPING, Diagnostic.LINKING_DIAGNOSTIC)
		result.assertWarning(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)

		result.assertError(GtsMorpherPackage.Literals.OBJECT_MAPPING, Diagnostic.LINKING_DIAGNOSTIC)
		result.assertError(GtsMorpherPackage.Literals.LINK_MAPPING, Diagnostic.LINKING_DIAGNOSTIC)

		assertTrue(issues.length == 15)
	}

	/**
	 * Tests validation of GTS specifications
	 */
	@Test
	def void invalidGTSSpecification() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "devsmmRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine 
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		// Expecting validation errors as there is an invalid GTS specification
		val issues = result.validate()

		result.mappings.head.source.assertError(GtsMorpherPackage.Literals.GTS_SPECIFICATION,
			GTSMorpherValidator.INVALID_BEHAVIOUR_SPEC)

		assertTrue("Also failed check on target GTS", issues.length == 4) // There's also three incomplete mapping warnings (one for the metamodel and two for the rules)
	}

	/**
	 * Tests how the validator handles a missing metamodel specification.
	 */
	@Test
	def void scopingHandlesMissingMetamodel() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
			//		metamodel: "devsmm"
				} 
				to {
					metamodel: "server" 
				}
				type_mapping{ 
					class devsmm.Machine => server.Server
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		// Expecting validation errors as there is an invalid GTS specification
		result.validate()
	}

	/**
	 * Tests validation against duplicate mappings
	 */
	@Test
	def void duplicateMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine 
					class server.Server => devsmm.Assemble 
					reference server.Server.In => devsmm.Machine.in 
					reference server.Server.In => devsmm.Machine.out
					reference server.Queue.elts => devsmm.Container.parts
				}
				
				behaviour_mapping {
					rule process to process {
						object server => machine
						object server => machine
						link [in_queue->input:elts] => [tray->in_part:parts]
						link [in_queue->input:elts] => [tray->in_part:parts]
					}
					rule process to process {
						object input => in_part
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		// Expecting validation errors as there are duplicate mappings
		val issues = result.validate()

		result.mappings.head.typeMapping.mappings.get(1).assertError(GtsMorpherPackage.Literals.CLASS_MAPPING,
			GTSMorpherValidator.DUPLICATE_CLASS_MAPPING, "Duplicate mapping for EClassifier Server.")
		result.mappings.head.typeMapping.mappings.get(3).assertError(GtsMorpherPackage.Literals.REFERENCE_MAPPING,
			GTSMorpherValidator.DUPLICATE_REFERENCE_MAPPING, "Duplicate mapping for EReference In.")

		result.mappings.head.behaviourMapping.mappings.get(1).assertError(GtsMorpherPackage.Literals.RULE_MAPPING,
			GTSMorpherValidator.DUPLICATE_RULE_MAPPING, "Duplicate mapping for Rule process.")

		val ruleMapping = result.mappings.head.behaviourMapping.mappings.get(0)
		ruleMapping.element_mappings.get(1).assertError(GtsMorpherPackage.Literals.OBJECT_MAPPING,
			GTSMorpherValidator.DUPLICATE_OBJECT_MAPPING, "Duplicate mapping for Object server.")
		ruleMapping.element_mappings.get(3).assertError(GtsMorpherPackage.Literals.LINK_MAPPING,
			GTSMorpherValidator.DUPLICATE_LINK_MAPPING, "Duplicate mapping for Link [in_queue->input:elts].")

		result.assertWarning(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)

		assertTrue(issues.length == 10)
	}

	/**
	 * Tests validation against mappings that aren't morphisms
	 */
	@Test
	def void nonMorphismMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					class server.Queue => devsmm.Container
					reference server.Server.Out => devsmm.Machine.out
					reference server.Server.In => devsmm.Machine.in
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		// Expecting validation errors as there are duplicate mappings
		val issues = result.validate()
		result.mappings.head.typeMapping.mappings.get(2).assertError(GtsMorpherPackage.Literals.REFERENCE_MAPPING,
			GTSMorpherValidator.NOT_A_CLAN_MORPHISM)
		result.mappings.head.typeMapping.mappings.get(3).assertError(GtsMorpherPackage.Literals.REFERENCE_MAPPING,
			GTSMorpherValidator.NOT_A_CLAN_MORPHISM)
		result.mappings.head.assertWarning(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
		assertTrue(issues.length == 3)
	}

	/**
	 * Tests validation against mappings that are behaviour morphisms
	 */
	@Test
	def void morphismBehaviourMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.GenHandle
					class server.Queue => devsmm.Conveyor
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule produce to generateHandle {
						object s => g
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()
		// Incomplete mapping errors 
		assertTrue(issues.length == 4)
	}

	/**
	 * Tests validation against mappings that are behaviour morphisms
	 */
	@Test
	def void morphismBehaviourMappingWithToEmptyRuleMappingSourceNotAnIdentity() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.GenHandle
					class server.Queue => devsmm.Conveyor
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule produce to virtual identity
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		result.mappings.head.behaviourMapping.mappings.get(0).assertError(
			GtsMorpherPackage.Literals.RULE_MAPPING, GTSMorpherValidator.TO_IDENTITY_RULE_MAPPING_WITH_NON_IDENTITY_SOURCE)

		// Incomplete mapping errors 
		assertTrue(issues.length == 4)
	}

	/**
	 * Tests validation against mappings that are behaviour morphisms
	 */
	@Test
	def void morphismBehaviourMappingWithToEmptyRuleMappingSourceIsAnIdentity() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.GenHandle
					class server.Queue => devsmm.Conveyor
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule addObserver to virtual identity
				}
			}
		''', createInterfaceResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		result.assertNoError(GTSMorpherValidator.TO_IDENTITY_RULE_MAPPING_WITH_NON_IDENTITY_SOURCE)

		// Incomplete mapping errors 
		assertTrue(issues.length == 4)
	}

	@Test
	def void morphismBehaviourMappingWithToVirtualRuleMappingSourceNotAnIdentity() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.GenHandle
					class server.Queue => devsmm.Conveyor
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule produce to virtual
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		// Incomplete mapping errors 
		assertTrue(issues.length == 3)
	}

	/**
	 * Tests validation against mappings that are not behaviour morphisms
	 */
	@Test
	def void nonMorphismBehaviourMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.Server => devsmm.GenHandle
					class server.Queue => devsmm.Conveyor
					reference server.Server.Out => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule produce to generateHandle {
						object s => g
						object q => c
						link [s->q:Out] => [c->h:parts]
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		result.assertError(GtsMorpherPackage.Literals.LINK_MAPPING, GTSMorpherValidator.NOT_A_RULE_MORPHISM)

		// Various incomplete mapping errors 
		assertTrue(issues.length == 5)
	}

	/**
	 * Tests that auto-completion validation works in positive case
	 */
	@Test
	def void validateAutoCompletePositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete map {
				from {
					metamodel: "A"
				}
				to {
					metamodel: "B"
				}
				
				type_mapping {
					class A.A1 => B.B1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoErrors(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
		result.assertNoWarnings(GtsMorpherPackage.Literals.TYPE_GRAPH_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
	}

	/**
	 * Tests that unique auto-completion validation works in negative case
	 */
	@Test
	def void validateUniqueAutoCompleteNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique map {
				from {
					metamodel: "A"
				}
				to {
					metamodel: "B"
				}
				
				type_mapping {
					class A.A1 => B.B1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoErrors(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
		result.assertNoWarnings(GtsMorpherPackage.Literals.TYPE_GRAPH_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)

		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.NO_UNIQUE_COMPLETION)
	}

	/**
	 * Tests that unique auto-completion validation works in negative case even with behaviour present
	 */
	@Test
	def void validateUniqueAutoCompleteNegativeWithBehaviour() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique map {
				from {
					metamodel: "A"
					behaviour: "ARules"
				}
				
				to {
					metamodel: "B"
					behaviour: "BRules"
				}
				
				type_mapping {
					class A.A1 => B.B1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoErrors(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
		result.assertNoWarnings(GtsMorpherPackage.Literals.TYPE_GRAPH_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)

		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.NO_UNIQUE_COMPLETION)
	}

	/**
	 * Tests that unique auto-completion validation works in positive case even with behaviour present.
	 * 
	 * This is an interesting case because there are multiple type-graph mappings, but only one of them remains 
	 * a valid completion when considering the possible behaviour mappings.
	 */
	@Test
	def void validateUniqueAutoCompletePositiveWithBehaviour() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete unique map {
				from {
					metamodel: "A"
					behaviour: "ARules"
				}
				
				to {
					metamodel: "B"
					behaviour: "B2Rules"
				}
				
				type_mapping {
					class A.A1 => B.B1
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoErrors(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
		result.assertNoWarnings(GtsMorpherPackage.Literals.TYPE_GRAPH_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)

		result.assertNoError(GTSMorpherValidator.NO_UNIQUE_COMPLETION)
	}

	/**
	 * Tests that auto-completion validation works in the negative case
	 */
	@Test
	def void validateAutoCompleteNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
					class server.Queue => devsmm.Container
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
		result.assertNoWarnings(GtsMorpherPackage.Literals.TYPE_GRAPH_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
	}

	/**
	 * Tests auto-completion of behaviour morphisms
	 */
	@Test
	def void validateAutoCompleteBehaviourMapping() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
				behaviour_mapping {
					rule process to process {
						object server => server
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		// For now 
		// TODO: update with proper size
		assertTrue(issues.empty)
	// TODO Add more meaningful tests
	}

	/**
	 * Tests auto-completion of behaviour morphisms with empty rule map
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithEmptyRuleMap() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
				behaviour_mapping {
					rule process to process {
					}
				}
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		// For now 
		assertTrue(issues.empty)
	// TODO Add more meaningful tests
	}

	/**
	 * Tests auto-completion of behaviour morphisms claiming identity-only
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithIdentityOnlyRuleMapNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete to-identity-only map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					//behaviour: "serverRules"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		val issues = result.validate()

		assertFalse("Expected to see issues", issues.empty)
		result.assertError (GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.UNCOMPLETABLE_BEHAVIOUR_MAPPING)
	}

	/**
	 * Tests auto-completion of behaviour morphisms claiming identity-only. Here, the rules can all be 
	 * mapped to existing rules, so no virtual rules are needed at all.
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithIdentityOnlyRuleMapPositiveNoVirtualNeeded() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete to-identity-only map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		result.validate()

		result.assertNoIssues
	}
	
	/**
	 * Tests auto-completion of behaviour morphisms claiming identity-only. Here, auto-completion actually needs 
	 * to generate virtual rules, both of which can be identity rules.
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithIdentityOnlyRuleMapPositiveVirtualNeeded() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete to-identity-only map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
				}
				
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		result.validate()

		result.assertNoIssues
	}

	/**
	 * Tests auto-completion of behaviour morphisms claiming identity-only. Here, auto-completion actually needs 
	 * to generate virtual rules, both of which can be identity rules.
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithIdentityOnlyRuleMapNegativeVirtualNeeded() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete to-identity-only map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		result.validate()

		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.UNCOMPLETABLE_BEHAVIOUR_MAPPING) 
	}

	/**
	 * Tests auto-completion of behaviour morphisms claiming identity-only. Here, auto-completion actually needs 
	 * to generate virtual rules, both of which can be identity rules.
	 */
	@Test
	def void validateAutoCompleteBehaviourMappingWithoutRuleMapNegativeVirtualNeeded() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			auto-complete without-to-virtual map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
				}
				
				type_mapping {
					class server.Server => server.Server
					class server.Queue => server.Queue
					class server.Element => server.Element
					class server.Input => server.Input
					class server.Output => server.Output
					reference server.Server.Out => server.Server.Out
					reference server.Server.In => server.Server.In
					reference server.Queue.elts => server.Queue.elts
				}
				
			}
		''', createNormalResourceSet)

		assertNotNull("Did not produce parse result", result)
		result.validate()

		result.assertError(GtsMorpherPackage.Literals.GTS_MAPPING, GTSMorpherValidator.UNCOMPLETABLE_BEHAVIOUR_MAPPING) 
	}

	/**
	 * Tests that completeness check works correctly for complete mappings
	 */
	@Test
	def void validateCompletenessPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
				}
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Element => devsmm.Part
					class server.Queue => devsmm.Tray
					class server.Server => devsmm.Machine
					class server.Input => devsmm.Part
					class server.Output => devsmm.Part
					reference server.Server.In => devsmm.Machine.in
					reference server.Server.Out => devsmm.Machine.in
					reference server.Queue.elts => devsmm.Container.parts
				} 
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoWarnings(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
	}

	/**
	 * Tests that completeness check works correctly for complete mappings with behaviour mappings
	 */
	@Test
	def void validateBehaviourCompletenessPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					reference server.Queue.elts => server.Queue.elts
					class server.Element => server.Element
					class server.Input => server.Input
					reference server.Server.Out => server.Server.Out
					class server.Output => server.Output
					class server.Server => server.Server
					class server.Queue => server.Queue
					reference server.Server.In => server.Server.In
				}
				behaviour_mapping {
					rule process to process {
						object output => output
						object server => server
						object input => input
						object out_queue => in_queue
						object in_queue => in_queue
						link [out_queue->output:elts] => [out_queue->output:elts]
						link [server->in_queue:In] => [server->in_queue:In]
						link [server->out_queue:Out] => [server->out_queue:Out]
						link [in_queue->input:elts] => [in_queue->input:elts]
					}
					
					rule produce to produce {
						link [q->o:elts] => [q->o:elts]
						object q => q
						object s => s
						link [s->q:Out] => [s->q:Out]
						object o => o
					}
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoWarnings(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
		result.assertNoIssue(GtsMorpherPackage.Literals.RULE_MAPPING, GTSMorpherValidator.INCOMPLETE_RULE_MAPPING)
	}

	/**
	 * Tests that completeness check works correctly for complete mappings with behaviour mappings in the presence of interface annotations
	 */
	@Test
	def void validateBehaviourWithInterfaceCompletenessPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "server"
					behaviour: "serverRules"
				}
				
				type_mapping {
					reference server.Queue.elts => server.Queue.elts
					class server.Element => server.Element
					class server.Input => server.Input
					reference server.Server.Out => server.Server.Out
					class server.Output => server.Output
					class server.Server => server.Server
					class server.Queue => server.Queue
					reference server.Server.In => server.Server.In
				}
				behaviour_mapping {
					rule process to process {
						object output => output
						object server => server
						object input => input
						object out_queue => in_queue
						object in_queue => in_queue
						link [out_queue->output:elts] => [out_queue->output:elts]
						link [server->in_queue:In] => [server->in_queue:In]
						link [server->out_queue:Out] => [server->out_queue:Out]
						link [in_queue->input:elts] => [in_queue->input:elts]
					}
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertNoWarnings(GtsMorpherPackage.Literals.GTS_MAPPING,
			GTSMorpherValidator.INCOMPLETE_TYPE_GRAPH_MAPPING)
		result.assertNoIssue(GtsMorpherPackage.Literals.RULE_MAPPING, GTSMorpherValidator.INCOMPLETE_RULE_MAPPING)
	}

	/**
	 * Tests that in interface-mappings we cannot map non-interface elements
	 */
	@Test
	def void validateNonInterfaceElementMappingAttempts() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from interface_of {
					metamodel: "server"
					behaviour: "serverRules"
				}
				to {
					metamodel: "devsmm"
					behaviour: "devsmmRules"
				}
				
				type_mapping {
					class server.ServerObserver => devsmm.Machine
					reference server.ServerObserver.server => devsmm.Machine.out
				}
				
				behaviour_mapping {
					rule process to process {
						object so => machine
						link [so->server:server] => [machine->conveyor:out]
					}
				}
			}
		''', createInterfaceResourceSet)
		assertNotNull("Did not produce parse result", result)

		result.assertError(GtsMorpherPackage.Literals.CLASS_MAPPING,
			GTSMorpherValidator.NON_INTERFACE_CLASS_MAPPING_ATTEMPT)
		result.assertError(GtsMorpherPackage.Literals.REFERENCE_MAPPING,
			GTSMorpherValidator.NON_INTERFACE_REFERENCE_MAPPING_ATTEMPT)

		/*
		 * Removed: these are now checked by the scoping mechanism, so the mapper never gets a look in...
		 * 
		result.assertError(GtsMorpherPackage.Literals.OBJECT_MAPPING,
			GTSMorpherValidator.NON_INTERFACE_OBJECT_MAPPING_ATTEMPT)
		result.assertError(GtsMorpherPackage.Literals.LINK_MAPPING,
			GTSMorpherValidator.NON_INTERFACE_LINK_MAPPING_ATTEMPT)
		result.assertNoError(GTSMorpherValidator.NOT_A_RULE_MORPHISM)
		* 
		*/
	}

	/**
	 * Test validation of transformer rules with a GTS family specification
	 */
	@Test
	def void validateBasicGTSFamilyNegative() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					family: {
						{
							metamodel: "server"
						}
						
						transformers: "serverRules"
					}
					
					using [
						addSubClass(server.Server, "Server1"),
						addSubClass(server.Server, "Server2")
					]
				}
				
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		result.assertError(GtsMorpherPackage.Literals.GTS_FAMILY_SPECIFICATION,
			GTSMorpherValidator.INVALID_TRANSFORMER_SPECIFICATION)
	}

	/**
	 * Test validation of transformer rules with a GTS family specification
	 */
	@Test
	def void validateBasicGTSFamilyPositive() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					family: {
						{
							metamodel: "server"
						}
						
						transformers: "transformerRules"
					}
					
					using [
						addSubClass(server.Server, "Server1"),
						addSubClass(server.Server, "Server2")
					]
				}
				
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		result.assertNoError(GTSMorpherValidator.INVALID_TRANSFORMER_SPECIFICATION)
	}

	/**
	 * Test validation of transformer unit calls with a GTS family specification
	 */
	@Test
	def void validateBasicGTSFamilyUnitCalls() {
		// TODO At some point may want to change this so it works with actual URLs rather than relying on Xtext/Ecore to pick up and search all the available ecore files
		// Then would use «serverURI.toString» etc. below
		val result = parseHelper.parse('''
			map {
				from {
					family: {
						{
							metamodel: "server"
						}
						
						transformers: "transformerRules"
					}
					
					using [
						addSubClass("Server1"),
						addSubClass("Server2", server.Server)
					]
				}
				
				to {
					metamodel: "devsmm"
				}
				
				type_mapping {
					class server.Server => devsmm.Machine
				}
			}
		''', createNormalResourceSet)
		assertNotNull("Did not produce parse result", result)
		assertTrue("Found parse errors: " + result.eResource.errors, result.eResource.errors.isEmpty)

		result.assertNoError(GTSMorpherValidator.INVALID_TRANSFORMER_SPECIFICATION)

		result.assertError(GtsMorpherPackage.Literals.UNIT_CALL,
			GTSMorpherValidator.WRONG_PARAMETER_NUMBER_IN_UNIT_CALL)
		result.assertError(GtsMorpherPackage.Literals.EOBJECT_REFERENCE_PARAMETER,
			GTSMorpherValidator.INVALID_UNIT_CALL_PARAMETER_TYPE)
		result.assertError(GtsMorpherPackage.Literals.STRING_PARAMETER,
			GTSMorpherValidator.INVALID_UNIT_CALL_PARAMETER_TYPE)
	}
}
