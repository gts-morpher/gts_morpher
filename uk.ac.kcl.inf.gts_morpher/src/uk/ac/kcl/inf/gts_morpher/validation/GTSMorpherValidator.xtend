/*
 * generated by Xtext 2.18.0.M3
 */
package uk.ac.kcl.inf.gts_morpher.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Map.Entry
import java.util.Set
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.henshin.model.Edge
import org.eclipse.emf.henshin.model.HenshinPackage
import org.eclipse.emf.henshin.model.Node
import org.eclipse.emf.henshin.model.ParameterKind
import org.eclipse.emf.henshin.model.Rule
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.BehaviourMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ClassMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.EObjectReferenceParameter
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSFamilyChoice
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSFamilySpecification
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSMappingInterfaceSpec
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSMappingRef
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSMappingRefOrInterfaceSpec
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSSpecification
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GTSWeave
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.GtsMorpherPackage
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.LinkMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.NumericParameter
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ObjectMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.ReferenceMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.RuleMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.StringParameter
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.TypeGraphMapping
import uk.ac.kcl.inf.gts_morpher.gtsMorpher.UnitCall
import uk.ac.kcl.inf.gts_morpher.util.GTSSpecificationHelper.UnitCallIssue
import uk.ac.kcl.inf.gts_morpher.util.MappingConverter
import uk.ac.kcl.inf.gts_morpher.util.MappingConverter.IssueAcceptor
import uk.ac.kcl.inf.gts_morpher.util.MorphismCompleter
import uk.ac.kcl.inf.gts_morpher.util.ValueHolder

import static uk.ac.kcl.inf.gts_morpher.util.MappingConverter.*
import static uk.ac.kcl.inf.gts_morpher.util.MorphismChecker.*

import static extension uk.ac.kcl.inf.gts_morpher.util.EMFHelper.*
import static extension uk.ac.kcl.inf.gts_morpher.util.GTSSpecificationHelper.*
import static extension uk.ac.kcl.inf.gts_morpher.util.HenshinChecker.isIdentityRule
import static extension uk.ac.kcl.inf.gts_morpher.util.MorphismCompleter.*
import static extension uk.ac.kcl.inf.gts_morpher.validation.GTSMorpherValidatorHelper.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GTSMorpherValidator extends AbstractGTSMorpherValidator implements GTSMorpherValidatorHelper.IssueAcceptor{
	public static val DUPLICATE_CLASS_MAPPING = MappingConverter.DUPLICATE_CLASS_MAPPING
	public static val DUPLICATE_REFERENCE_MAPPING = MappingConverter.DUPLICATE_REFERENCE_MAPPING
	public static val DUPLICATE_ATTRIBUTE_MAPPING = MappingConverter.DUPLICATE_ATTRIBUTE_MAPPING
	public static val NOT_A_CLAN_MORPHISM = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.NOT_A_CLAN_MORPHISM'
	public static val INCOMPLETE_TYPE_GRAPH_MAPPING = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCOMPLETE_TYPE_GRAPH_MAPPING'
	public static val UNCOMPLETABLE_TYPE_GRAPH_MAPPING = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.UNCOMPLETABLE_TYPE_GRAPH_MAPPING'
	public static val UNCOMPLETABLE_BEHAVIOUR_MAPPING = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.UNCOMPLETABLE_BEHAVIOUR_MAPPING'
	public static val NO_UNIQUE_COMPLETION = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.NO_UNIQUE_COMPLETION'
	public static val UNIQUE_COMPLETION_NOT_CHECKED = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.UNIQUE_COMPLETION_NOT_CHECKED'
	public static val DUPLICATE_RULE_MAPPING = MappingConverter.DUPLICATE_RULE_MAPPING
	public static val DUPLICATE_PARAMETER_MAPPING = MappingConverter.DUPLICATE_PARAMETER_MAPPING
	public static val DUPLICATE_OBJECT_MAPPING = MappingConverter.DUPLICATE_OBJECT_MAPPING
	public static val DUPLICATE_LINK_MAPPING = MappingConverter.DUPLICATE_LINK_MAPPING
	public static val DUPLICATE_SLOT_MAPPING = MappingConverter.DUPLICATE_SLOT_MAPPING
	public static val INVALID_BEHAVIOUR_SPEC = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INVALID_BEHAVIOUR_SPEC'
	public static val NOT_A_RULE_MORPHISM = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.NOT_A_RULE_MORPHISM'
	public static val INCOMPLETE_RULE_MAPPING = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCOMPLETE_RULE_MAPPING'
	public static val INCOMPLETE_BEHAVIOUR_MAPPING = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCOMPLETE_BEHAVIOUR_MAPPING'
	public static val NON_INTERFACE_CLASS_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_CLASS_MAPPING_ATTEMPT
	public static val NON_INTERFACE_REFERENCE_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_REFERENCE_MAPPING_ATTEMPT
	public static val NON_INTERFACE_ATTRIBUTE_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_ATTRIBUTE_MAPPING_ATTEMPT
	public static val NON_INTERFACE_OBJECT_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_OBJECT_MAPPING_ATTEMPT
	public static val NON_INTERFACE_LINK_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_LINK_MAPPING_ATTEMPT
	public static val NON_INTERFACE_SLOT_MAPPING_ATTEMPT = MappingConverter.NON_INTERFACE_SLOT_MAPPING_ATTEMPT
	public static val INVALID_TRANSFORMER_SPECIFICATION = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INVALID_TRANSFORMER_SPECIFICATION'
	public static val WRONG_PARAMETER_NUMBER_IN_UNIT_CALL = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.WRONG_PARAMETER_NUMBER_IN_UNIT_CALL'
	public static val INVALID_UNIT_CALL_PARAMETER_TYPE = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INVALID_UNIT_CALL_PARAMETER_TYPE'
	public static val GTS_FAMILY_ISSUE = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.GTS_FAMILY_ISSUE'
	public static val TO_IDENTITY_RULE_MAPPING_WITH_NON_IDENTITY_SOURCE = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.TO_IDENTITY_RULE_MAPPING_WITH_NON_IDENTITY_SOURCE'
	public static val WEAVE_WITH_DIFFERENT_SOURCES = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.WEAVE_WITH_DIFFERENT_SOURCES'
	public static val WEAVE_WITH_INVALID_MORPHISM = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.WEAVE_WITH_INVALID_MORPHISM'
	public static val GTS_WEAVE_ISSUE = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.GTS_WEAVE_ISSUE'
	public static val INCLUSION_CANNOT_BE_TO_IDENTITY_ONLY = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCLUSION_CANNOT_BE_TO_IDENTITY_ONLY'
	public static val INCLUSION_CANNOT_BE_WITHOUT_TO_VIRTUAL = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCLUSION_CANNOT_BE_WITHOUT_TO_VIRTUAL'
	public static val INCLUSION_CANNOT_BE_ALLOW_FROM_EMPTY = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCLUSION_CANNOT_BE_ALLOW_FROM_EMPTY'
	public static val INCLUSION_MUST_HAVE_SAME_SOURCE_AND_TARGET = 'uk.ac.kcl.inf.gts_morpher.xdsml_compose.INCLUSION_MUST_HAVE_SAME_SOURCE_AND_TARGET'

	/**
	 * Check that the rules in a GTS specification refer to the metamodel package
	 */
	@Check
	def checkGTSSpecConsistent(GTSSpecification gts) {
		if (gts.behaviour !== null) {
			if (!gts.behaviour.imports.contains(gts.metamodel)) {
				error("Inconsistent GTS specification: Rules need to be typed over metamodel.",
					GtsMorpherPackage.Literals.GTS_SPECIFICATION__GTS, INVALID_BEHAVIOUR_SPEC)
			}
		}
	}

	/**
	 * Check that no source EClass or EReference is mapped more than once in the given mapping.
	 */
	@Check
	def checkMapsUniqueSources(TypeGraphMapping mapping) {
		mapping.extractMapping
	}

	/**
	 * Check that no rule is mapped more than once in the given mapping.
	 */
	@Check
	def checkMapsUniqueRules(BehaviourMapping mapping) {
		mapping.extractMapping
	}

	/**
	 * Check that the given mappings do not violate the rules for clan morphisms
	 */
	@Check
	def checkIsMorphismMaybeIncomplete(GTSMapping mapping) {
		checkIsMorphismMaybeIncomplete(mapping, true)
	}

	private def boolean checkIsMorphismMaybeIncomplete(GTSMapping mapping, boolean issueErrors) {
		val result = new ValueHolder(true)

		var typeMapping = extractMapping(mapping.typeMapping)
		val isValidTypeMorphism = checkValidMaybeIncompleteClanMorphism(typeMapping, [ object, message |
			if (object instanceof EClassifier) {
				result.value = false

				if (issueErrors) {
					error(message, mapping.typeMapping.mappings.filter(ClassMapping).findFirst[m|m.source == object],
						GtsMorpherPackage.Literals.CLASS_MAPPING__TARGET, NOT_A_CLAN_MORPHISM)
				}
			} else if (object instanceof EReference) {
				result.value = false

				if (issueErrors) {
					error(message, mapping.typeMapping.mappings.filter(ReferenceMapping).findFirst [ m |
						m.source == object
					], GtsMorpherPackage.Literals.REFERENCE_MAPPING__TARGET, NOT_A_CLAN_MORPHISM)
				}
			}
		])

		if (isValidTypeMorphism) {
			val srcIsInterface = mapping.source.interface_mapping
			checkValidMaybeIncompleteBehaviourMorphism(typeMapping,
				extractMapping(mapping.behaviourMapping), [ object, message |
					if (object instanceof Rule) {
						// Interface mapping may create spuriour kernel mismatch errors, which we shouldn't reflect to the user
						if (!srcIsInterface || (message != GENERAL_KERNEL_MISMATCH)) {
							result.value = true
							if (issueErrors) {
								error(message, mapping.behaviourMapping.mappings.findFirst [ rm |
									rm.source == object as Rule
								], GtsMorpherPackage.Literals.RULE_MAPPING__TARGET, NOT_A_RULE_MORPHISM)
							}
						}
					} else if (object instanceof Edge) {
						if (!srcIsInterface || isInterfaceElement(object.type)) {
							result.value = true
							if (issueErrors) {
								error(message, mapping.behaviourMapping.mappings.map [ rm |
									rm.element_mappings.filter(LinkMapping)
								].flatten.findFirst [ lm |
									lm.source == object as Edge
								], GtsMorpherPackage.Literals.LINK_MAPPING__SOURCE, NOT_A_RULE_MORPHISM)
							}
						}
					} else if (object instanceof Node) {
						if (!srcIsInterface || isInterfaceElement(object.type)) {
							result.value = true
							if (issueErrors) {
								error(message, mapping.behaviourMapping.mappings.map [ rm |
									rm.element_mappings.filter(ObjectMapping)
								].flatten.findFirst [ om |
									om.source == object as Object
								], GtsMorpherPackage.Literals.OBJECT_MAPPING__SOURCE, NOT_A_RULE_MORPHISM)
							}
						}
					}
				])
		}

		result.value
	}

	/**
	 * Check that the given mapping is a complete type mapping
	 */
	@Check
	def checkIsCompleteTypeMapping(GTSMapping mapping) {
		if (!mapping.autoComplete && mapping.typeMapping.isInCompleteMapping) {
			warning("Incomplete mapping. Ensure all elements of the source metamodel are mapped.", mapping,
				GtsMorpherPackage.Literals.GTS_MAPPING__SOURCE, INCOMPLETE_TYPE_GRAPH_MAPPING)
		}
	}

	/**
	 * Check that the given behaviour mapping maps all rules and maps them completely
	 */
	@Check
	def checkIsCompleteBehaviourMapping(GTSMapping mapping) {
		if (!mapping.autoComplete) {
			doCheckIsCompleteBehaviourMapping(mapping, this)
		}
	}

	/**
	 * Check source of a to-identity rule map is an identity rule.
	 */
	@Check
	def checkToIdentityRuleMapSourceIsIdentity(RuleMapping rm) {
		if ((rm.target_identity) && (!rm.source.isIdentityRule(rm.sourceIsInterface))) {
			error("Source of to-identity rule mapping must be an identity rule.", rm,
				GtsMorpherPackage.Literals.RULE_MAPPING__SOURCE,
				GTSMorpherValidator.TO_IDENTITY_RULE_MAPPING_WITH_NON_IDENTITY_SOURCE)
		}
	}

	private def sourceIsInterface(RuleMapping rm) {
		(rm.eContainer.eContainer as GTSMapping).source.interface_mapping
	}

	/**
	 * Check that we can auto-complete, if requested to do so
	 */
	@Check
	def checkCanAutoCompleteMapping(GTSMapping mapping) {
		if (!checkMode.shouldCheck(CheckType.EXPENSIVE)) {
			mapping.checkCompletability(false)
		}
	}

	/**
	 * Check that we can uniquely auto-complete, if requested to do so
	 */
	@Check(EXPENSIVE)
	def checkCanUniquelyAutoCompleteMapping(GTSMapping mapping) {
		mapping.checkCompletability(true)
	}

	/**
	 * Helper function for completability checking factoring repeated code from the two variants of the check as above.
	 */
	private def checkCompletability(GTSMapping mapping, boolean checkUniqueness) {
		checkCompletability(mapping, checkUniqueness, true)
	}

	/**
	 * Helper function for completability checking factoring repeated code from the two variants of the check as above.
	 * 
	 * @param issueErrors set to false to indicate that no errors should be produced. Only the result will be set
	 */
	private def boolean checkCompletability(GTSMapping mapping, boolean checkUniqueness, boolean issueErrors) {
		var result = true
		if (mapping.autoComplete) {
			// Check we can auto-complete type mapping
			val typeMapping = mapping.typeMapping
			val _typeMapping = typeMapping.extractMapping

			if (typeMapping.isInCompleteMapping || !mapping.doCheckIsCompleteBehaviourMapping(null)) {
				if (checkValidMaybeIncompleteClanMorphism(_typeMapping, null)) {
					val completions = mapping.getMorphismCompletions(checkUniqueness)
					val morphismCompleter = completions.key

					if (completions.value != 0) {
						if (!morphismCompleter.completedTypeMapping) {
							result = false
							if (issueErrors) {
								error("Cannot complete type mapping to a valid morphism", mapping,
									GtsMorpherPackage.Literals.GTS_MAPPING__TYPE_MAPPING,
									UNCOMPLETABLE_TYPE_GRAPH_MAPPING)
							}
						} else {
							result = false
							if (issueErrors) {
								error("Cannot complete behaviour mapping to a valid morphism", mapping,
									GtsMorpherPackage.Literals.GTS_MAPPING__BEHAVIOUR_MAPPING,
									UNCOMPLETABLE_BEHAVIOUR_MAPPING)
							}
						}
					} else if (mapping.uniqueCompletion) {
						if (checkUniqueness) {
							if (morphismCompleter.completedMappings.size > 1) {
								// Found more than one mapping (this can only happen if we were looking for all mappings), so need to report this as an error
								result = false

								if (issueErrors) {
									val sortedImprovements = morphismCompleter.findImprovementOptions

									// TODO Propose fixes for behaviour mapping completions, too
									error('''Found «morphismCompleter.completedMappings.size» potential completions. Consider mapping «sortedImprovements.head.mapMessage» to improve uniqueness.''',
										mapping, GtsMorpherPackage.Literals.GTS_MAPPING__UNIQUE_COMPLETION,
										NO_UNIQUE_COMPLETION, sortedImprovements.map [ e |
											e.value.map[eo|e.key.issueData(eo).toString]
										].flatten)
								}
							} else {
								println("Validation ran and confirmed that morphism can be uniquely completed.")
							}
						} else {
							warning(
								"Uniqueness of mapping has not been checked. Please run explicit validation from editor context menu to check this.",
								mapping, GtsMorpherPackage.Literals.GTS_MAPPING__UNIQUE_COMPLETION,
								UNIQUE_COMPLETION_NOT_CHECKED)
						}
					}
				}
			} else {
				warning("Morphism is already complete", mapping, GtsMorpherPackage.Literals.GTS_MAPPING__AUTO_COMPLETE)
			}
		}

		result
	}

	/**
	 * Check transformer specification is a validly typed Henshin module.
	 */
	@Check
	def checkValidTransformers(GTSFamilySpecification familySpec) {
		if (familySpec.transformers !== null) {
			if ((!familySpec.transformers.imports.contains(EcorePackage.eINSTANCE)) ||
				(!familySpec.transformers.imports.contains(HenshinPackage.eINSTANCE)) ||
				(familySpec.transformers.imports.size > 2)) {
				error("Transformer rules must be typed over Henshin rules and Ecore metamodels only.", familySpec,
					GtsMorpherPackage.Literals.GTS_FAMILY_SPECIFICATION__TRANSFORMERS,
					INVALID_TRANSFORMER_SPECIFICATION)
			}
		}
	}

	/**
	 * Check unit call parameter fit
	 */
	@Check
	def checkValidUnitCallParameters(UnitCall call) {
		val unitParams = call.unit.parameters.filter[p|p.kind != ParameterKind.VAR]
		if (unitParams.size != call.params.parameters.size) {
			error('''Wrong number of parameters in transformer call. Was given «call.params.parameters.size» parameters, but expected «unitParams.size».''',
				call, GtsMorpherPackage.Literals.UNIT_CALL__PARAMS, WRONG_PARAMETER_NUMBER_IN_UNIT_CALL)
		} else {
			call.params.parameters.forEach [ p1, idx |
				val p2 = unitParams.get(idx)
				if (p1 instanceof EObjectReferenceParameter) {
					if ((!(p2.type instanceof EClass)) ||
						((!EcorePackage.Literals.ESTRUCTURAL_FEATURE.isSuperTypeOf(p2.type as EClass)) &&
							(!EcorePackage.Literals.ECLASSIFIER.isSuperTypeOf(p2.type as EClass)) &&
							(!HenshinPackage.Literals.MODEL_ELEMENT.isSuperTypeOf(p2.type as EClass)))) {
						error("Transformer requires to be called with a non-Ecore parameter in this positon.", p1,
							GtsMorpherPackage.Literals.EOBJECT_REFERENCE_PARAMETER__QUALIFIED_NAME,
							INVALID_UNIT_CALL_PARAMETER_TYPE)
					}
				} else if (p1 instanceof StringParameter) {
					if (p2.type != EcorePackage.Literals.ESTRING) {
						error(
							"Transformer requires to be called with a class or reference identifier in this position.",
							p1,
							GtsMorpherPackage.Literals.STRING_PARAMETER__VALUE,
							INVALID_UNIT_CALL_PARAMETER_TYPE
						)
					}
				} else if (p1 instanceof NumericParameter) {
					if (p2.type != EcorePackage.Literals.EINT) {
						error(
							"Transformer requires to be called with a class or reference identifier in this position.",
							p1,
							GtsMorpherPackage.Literals.NUMERIC_PARAMETER__VALUE,
							INVALID_UNIT_CALL_PARAMETER_TYPE
						)
					}
				}
			]
		}
	}

	/**
	 * Report any issues from processing GTS family transformations.
	 */
	@Check
	def checkGTSFamilyChoiceIssues(GTSFamilyChoice gts) {
		gts.issues.forEach [ i |
			error(i.message, (i as UnitCallIssue).unitCall, GtsMorpherPackage.Literals.UNIT_CALL__UNIT,
				GTS_FAMILY_ISSUE)
		]
	}

	@Check
	def checkInclusionValidity(GTSMapping mapping) {
		if (mapping.autoComplete && mapping.uniqueCompletion && mapping.inclusion) {
			if (mapping.toIdentityOnly) {
				error("An inclusion mapping completion cannot be to-identity-only", mapping,
					GtsMorpherPackage.Literals.GTS_MAPPING__TO_IDENTITY_ONLY, INCLUSION_CANNOT_BE_TO_IDENTITY_ONLY)
			}

			if (mapping.withoutToVirtual) {
				error("An inclusion mapping completion cannot be without-to-virtual", mapping,
					GtsMorpherPackage.Literals.GTS_MAPPING__WITHOUT_TO_VIRTUAL, INCLUSION_CANNOT_BE_WITHOUT_TO_VIRTUAL)
			}

			if (mapping.allowFromEmtpy) {
				error("An inclusion mapping completion cannot be allow-from-empty", mapping,
					GtsMorpherPackage.Literals.GTS_MAPPING__ALLOW_FROM_EMTPY, INCLUSION_CANNOT_BE_ALLOW_FROM_EMPTY)
			}

			if (mapping.source?.metamodel !== mapping.target?.metamodel) {
				error(
					"An inclusion mapping completion must have the same source and target metamodel up to interface-of filtering",
					mapping, GtsMorpherPackage.Literals.GTS_MAPPING__INCLUSION,
					INCLUSION_MUST_HAVE_SAME_SOURCE_AND_TARGET)
			} else if (mapping.source?.behaviour !== mapping.target?.behaviour) {
				error(
					"An inclusion mapping completion must have the same source and target rules up to interface-of filtering",
					mapping, GtsMorpherPackage.Literals.GTS_MAPPING__INCLUSION,
					INCLUSION_MUST_HAVE_SAME_SOURCE_AND_TARGET)
			}
		}
	}

	/**
	 * Checks weavings to ensure they start from common sources.
	 */
	@Check
	def checkWeaveHasCommonSource(GTSWeave weave) {
		val map1Source = weave.mapping1.source
		val map2Source = weave.mapping2.source
		if ((map1Source.metamodel !== map2Source.metamodel) || (map1Source.behaviour !== map2Source.behaviour) ||
			(map1Source.interface_mapping !== map2Source.interface_mapping)) {
			error("Weaving requires both mappings to have the same source GTS.", weave.eContainer,
				GtsMorpherPackage.Literals.GTS_SPECIFICATION__GTS, WEAVE_WITH_DIFFERENT_SOURCES)
		}
	}

	/**
	 * Check weavings to ensure they're based on valid mappings
	 */
	@Check
	def checkWeaveHasValidMappings(GTSWeave weave) {
		weave.mapping1.checkIsValidMapping
		weave.mapping2.checkIsValidMapping
	}

	/**
	 * Report any issues from processing GTS weave transformations.
	 */
	@Check
	def checkGTSWeaveIssues(GTSWeave gts) {
		gts.issues.forEach [ i |
			error(i.message, gts.eContainer, GtsMorpherPackage.Literals.GTS_SPECIFICATION__GTS, GTS_WEAVE_ISSUE)
		]
	}

	private dispatch def checkIsValidMapping(Void spec) {}

	private dispatch def checkIsValidMapping(GTSMappingRefOrInterfaceSpec spec) {
		throw new IllegalStateException("checkIsValidMapping() not implemented for " + spec?.eClass?.name)
	}

	private dispatch def checkIsValidMapping(GTSMappingInterfaceSpec spec) {
		// Nothing to be done: these are fine by definition
	}

	private dispatch def checkIsValidMapping(GTSMappingRef ref) {
		val mapping = ref.ref

		if (!(
			(mapping.autoComplete && mapping.checkCompletability(true, false)) ||
			(!mapping.autoComplete && !mapping.typeMapping.isInCompleteMapping &&
				mapping.doCheckIsCompleteBehaviourMapping(null) && mapping.checkIsMorphismMaybeIncomplete(false)))) {
			val weave = ref.eContainer as GTSWeave
			error("Can only weave from complete and valid morphisms", weave, if (ref === weave.mapping1) {
				GtsMorpherPackage.Literals.GTS_WEAVE__MAPPING1
			} else {
				GtsMorpherPackage.Literals.GTS_WEAVE__MAPPING2
			}, WEAVE_WITH_INVALID_MORPHISM)
		}
	}

	private def findImprovementOptions(MorphismCompleter morphismCompleter) {
		// Sort all newly mapped elements by number of potential mappings, descending
		// and remove those elements with only one mapping
		morphismCompleter.completedMappings.fold(new HashMap<EObject, Set<EObject>>, [ _acc, mp |
			mp.entrySet.fold(_acc, [ acc, e |
				if (!acc.containsKey(e.key)) {
					acc.put(e.key, new HashSet<EObject>)
				}
				acc.get(e.key).add(e.value)

				acc
			])
		]).entrySet.filter[e|e.value.size > 1].sortWith[e1, e2|-(e1.value.size <=> e2.value.size)]
	}

	private def mapMessage(
		Entry<EObject, Set<EObject>> mappingChoices) '''«if (mappingChoices.key instanceof EClass) {'''class'''} else {'''reference'''}» «mappingChoices.key.qualifiedName» to any of [«mappingChoices.value.map[eo | eo.qualifiedName].join(', ')»]'''

	private def issueData(EObject source,
		EObject target) '''«if (source instanceof EClass) {'''class'''} else {'''reference'''}»:«source.qualifiedName»=>«target.qualifiedName»'''

	static val TYPE_MAPPINGS = GTSMorpherValidator.canonicalName + ".typeMappings"
	static val RULE_MAPPINGS = GTSMorpherValidator.canonicalName + ".ruleMappings"

	/**
	 * Extract the type mapping information as a Map. Also ensure no element is mapped more than once; report errors 
	 * otherwise. Expects to be called in a validation context.
	 */
	private def extractMapping(TypeGraphMapping mapping) {
		if (context.containsKey(TYPE_MAPPINGS)) {
			return context.get(TYPE_MAPPINGS) as Map<EObject, EObject>
		}

		val Map<EObject, EObject> _mapping = extractMapping(mapping, new IssueAcceptor() {
			override error(String message, EObject source, EStructuralFeature feature, String code,
				String... issueData) {
				GTSMorpherValidator.this.error(message, source, feature, code, issueData)
			}
		})

		context.put(TYPE_MAPPINGS, _mapping)

		_mapping
	}

	/**
	 * Extract the behaviour mapping information as a Map. Also ensure no element is mapped more than once; report errors 
	 * otherwise. Expects to be called in a validation context.
	 */
	private def extractMapping(BehaviourMapping mapping) {
		if (context.containsKey(RULE_MAPPINGS)) {
			return context.get(RULE_MAPPINGS) as Map<EObject, EObject>
		}

		val tgMapping = extractMapping((mapping.eContainer as GTSMapping).typeMapping, null)
		val Map<EObject, EObject> _mapping = extractMapping(mapping, tgMapping, new IssueAcceptor() {
			override error(String message, EObject source, EStructuralFeature feature, String code,
				String... issueData) {
				GTSMorpherValidator.this.error(message, source, feature, code, issueData)
			}
		})

		context.put(RULE_MAPPINGS, _mapping)

		_mapping
	}

	/**
	 * Return true if the given mapping is incomplete
	 */
	private def isInCompleteMapping(TypeGraphMapping mapping) {
		val _mapping = mapping.extractMapping
		mapping.isInCompleteMapping(_mapping)
	}
	
	override warning(String message, EObject source, EStructuralFeature feature, String code) {
		super.warning(message, source, feature, code)
	}
}
